import { 
  PlanRequest, 
  PlanResponse, 
  RunRequest, 
  RunResponse, 
  RunStatusResponse,
  CatalogResponse,
  ApiError,
  RunResults 
} from '../types/pentest';

export class CybrtyApiService {
  private baseURL: string;
  private token?: string;

  constructor() {
    this.baseURL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';
    this.token = localStorage.getItem('auth_token') || undefined;
  }

  private async request<T>(
    endpoint: string, 
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;
    
    const config: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...(this.token && { Authorization: `Bearer ${this.token}` }),
        ...options.headers,
      },
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        const errorData: ApiError = await response.json().catch(() => ({
          code: 'NETWORK_ERROR',
          message: `HTTP ${response.status}: ${response.statusText}`,
        }));
        
        throw new Error(`API Error: ${errorData.message} (${errorData.code})`);
      }

      return await response.json();
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Unknown API error occurred');
    }
  }

  private async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  private async post<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  // Authentication
  setAuthToken(token: string): void {
    this.token = token;
    localStorage.setItem('auth_token', token);
  }

  clearAuthToken(): void {
    this.token = undefined;
    localStorage.removeItem('auth_token');
  }

  // Health Check
  async healthCheck(): Promise<{ status: string; timestamp: string }> {
    return this.get('/api/v1/health');
  }

  // Generate Penetration Testing Plan
  async generatePlan(request: PlanRequest): Promise<PlanResponse> {
    return this.post('/api/v1/agents/pentest/plan', request);
  }

  // Execute Penetration Testing Run
  async executePlan(request: RunRequest): Promise<RunResponse> {
    return this.post('/api/v1/agents/pentest/run', request);
  }

  // Monitor Run Status
  async getRunStatus(runId: string): Promise<RunStatusResponse> {
    return this.get(`/api/v1/runs/${runId}`);
  }

  // Get Available Tools and Agents
  async getCatalog(): Promise<CatalogResponse> {
    return this.get('/api/v1/catalog');
  }

  // Get Run Results
  async getRunResults(runId: string): Promise<RunResults> {
    return this.get(`/api/v1/runs/${runId}/results`);
  }

  // Download Artifact
  async downloadArtifact(artifactId: string): Promise<Blob> {
    const response = await fetch(`${this.baseURL}/api/v1/artifacts/${artifactId}`, {
      headers: {
        ...(this.token && { Authorization: `Bearer ${this.token}` }),
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to download artifact: ${response.statusText}`);
    }

    return response.blob();
  }

  // Cancel Running Test
  async cancelRun(runId: string): Promise<{ success: boolean; message: string }> {
    return this.post(`/api/v1/runs/${runId}/cancel`, {});
  }

  // Pause Running Test
  async pauseRun(runId: string): Promise<{ success: boolean; message: string }> {
    return this.post(`/api/v1/runs/${runId}/pause`, {});
  }

  // Resume Paused Test
  async resumeRun(runId: string): Promise<{ success: boolean; message: string }> {
    return this.post(`/api/v1/runs/${runId}/resume`, {});
  }

  // Get Historical Runs
  async getHistoricalRuns(limit: number = 50): Promise<RunStatusResponse[]> {
    return this.get(`/api/v1/runs?limit=${limit}`);
  }

  // WebSocket for Real-time Updates
  subscribeToRun(
    runId: string, 
    callbacks: {
      onProgress?: (progress: RunStatusResponse['progress']) => void;
      onStatusChange?: (status: RunStatusResponse['status']) => void;
      onVulnerabilityFound?: (vulnerability: any) => void;
      onError?: (error: string) => void;
      onComplete?: (results: RunResults) => void;
    }
  ): () => void {
    const wsUrl = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8080/ws';
    const socket = new WebSocket(`${wsUrl}/runs/${runId}`);

    socket.onopen = () => {
      console.log(`WebSocket connected for run ${runId}`);
    };

    socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        
        switch (data.type) {
          case 'progress':
            callbacks.onProgress?.(data.data);
            break;
          case 'status_change':
            callbacks.onStatusChange?.(data.data);
            break;
          case 'vulnerability_found':
            callbacks.onVulnerabilityFound?.(data.data);
            break;
          case 'error':
            callbacks.onError?.(data.data.message);
            break;
          case 'complete':
            callbacks.onComplete?.(data.data);
            break;
          default:
            console.log('Unknown WebSocket message type:', data.type);
        }
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error);
        callbacks.onError?.('Failed to parse real-time update');
      }
    };

    socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      callbacks.onError?.('WebSocket connection error');
    };

    socket.onclose = () => {
      console.log('WebSocket connection closed');
    };

    // Return cleanup function
    return () => {
      socket.close();
    };
  }

  // Validate Target Format
  static validateTarget(target: string): { 
    isValid: boolean; 
    type: 'ip' | 'domain' | 'url' | 'cidr' | 'unknown'; 
    error?: string;
  } {
    // IP Address validation
    const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    if (ipRegex.test(target)) {
      return { isValid: true, type: 'ip' };
    }

    // CIDR notation validation
    const cidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\/(?:[0-9]|[1-2][0-9]|3[0-2])$/;
    if (cidrRegex.test(target)) {
      return { isValid: true, type: 'cidr' };
    }

    // Domain validation
    const domainRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    if (domainRegex.test(target)) {
      return { isValid: true, type: 'domain' };
    }

    // URL validation
    try {
      new URL(target);
      return { isValid: true, type: 'url' };
    } catch {
      // Not a valid URL
    }

    return { 
      isValid: false, 
      type: 'unknown', 
      error: 'Invalid target format. Please use IP address, CIDR notation, domain name, or URL.' 
    };
  }

  // Validate Target List
  static validateTargets(targets: string[]): {
    validTargets: string[];
    invalidTargets: Array<{ target: string; error: string }>;
    isValid: boolean;
  } {
    const validTargets: string[] = [];
    const invalidTargets: Array<{ target: string; error: string }> = [];

    targets.forEach(target => {
      const trimmedTarget = target.trim();
      if (!trimmedTarget) return;

      const validation = this.validateTarget(trimmedTarget);
      if (validation.isValid) {
        validTargets.push(trimmedTarget);
      } else {
        invalidTargets.push({
          target: trimmedTarget,
          error: validation.error || 'Invalid target format'
        });
      }
    });

    return {
      validTargets,
      invalidTargets,
      isValid: invalidTargets.length === 0 && validTargets.length > 0
    };
  }
}

// Default export and instance
export const pentestApi = new CybrtyApiService();
export default CybrtyApiService;